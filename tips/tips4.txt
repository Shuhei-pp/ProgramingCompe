ビット全探索
2**Nの回数でできる。
ちなみにビット化はbin(x)

bit.zfill(文字列の長さ)で0埋め可能。


関数
def ~~~~~~:
  print()

・2部探索はバカ早い。

・早えうちにcontinueして処理速度を上げよう

・DFS
→木構造の最長を求めるアルゴリズム
枝の先をfor文で再帰させdistance[葉]で根からの長さをとっておくことが大切

・あらかじめ値を配列に入れといて後から取り出すのも高速化につながる

・配列のsumではなく累積和にしておくと高速。

・combinationsというm個の要素の中からn個辞書順に出力する関数がある
